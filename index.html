<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H R & Y C 's Project</title>
    <link rel="icon" href="icon1.jpg"/> 
    <link rel="apple-touch-icon" href="icon1.jpg"/> 
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app">
        <div class="card">
            <div class="card-title">나이에 맞는 조언을 해드립니다!</div>

            <div class="content-row">
                <div class="cam-panel">
                    <div id="webcam-container"></div>
                </div>

                <div class="info-panel">
                    <div id="label-container">
                        <div id="result-title"></div>
                        <div id="result-age"></div>
                        <div id="result-advice"></div>
                        <div id="result-expire" style="display:none;font-size:12px;color:#777;margin-top:6px;"></div>
                    </div>
                </div>
            </div>

            <!-- 아래쪽 중앙: 프로그래스 바 + 버튼 -->
            <div class="bottom-panel">
                <div id="progress-wrapper">
                    <div id="progress-bar"></div>
                </div>
                <div id="progress-text"></div>

                <div class="button-row">
                    <button type="button" id="measure-button" onclick="onMeasureButtonClick()">조언 받기</button>
                </div>
                <div id="measure-hint" style="margin-top:6px;font-size:12px;color:#777;text-align:center;">SPACE BAR 또는 마우스로 버튼 클릭</div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <script type="text/javascript">
    // More API functions here:
    // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/image

    // the link to your model provided by Teachable Machine export panel
    const URL = "./";

    // 사용할 기본 테마 선택: "theme-light" | "theme-dark" | "theme-pastel" 중 하나
    const DEFAULT_THEME = "theme-light";

    // 페이지 로드가 완료되면 기본 테마 적용 + 웹캠/모델 초기화
    document.addEventListener("DOMContentLoaded", () => {
        document.body.classList.add(DEFAULT_THEME);
        init(); // 페이지에 들어오자마자 웹캠을 켜고 모델을 준비
        // 스페이스바로 측정 시작
        document.addEventListener("keydown", (e) => {
            if (e.code === "Space" || e.key === " ") {
                e.preventDefault(); // 페이지 스크롤 방지
                const measureButton = document.getElementById("measure-button");
                if (measureButton && !measureButton.disabled) {
                    onMeasureButtonClick();
                }
            }
        });
    });

    let model, webcam, labelContainer, maxPredictions;
    let resultTitleEl, resultAgeEl, resultAdviceEl, resultExpireEl;
    let autoResetTimerId = null;

    // 측정 시간(밀리초) - 필요하면 이 값만 바꾸면 됨
    const MEASURE_DURATION_MS = 5000;  // 5초
    const RESULT_AUTO_RESET_MS = 15000; // 결과 유지 시간(15초)

    // 평균을 내기 위한 상태 변수
    let isMeasuring = false;          // 지금 측정 중인지 여부
    let measurementDone = false;      // 최종 결과가 이미 나온 상태인지 여부
    let measureStartTime = 0;         // 측정 시작 시각
    let classScoreSums = [];          // 각 나이대에 대한 누적 점수

    // 연령대 이름을 따로 관리 (접두사 "예상 연령대:"는 코드에서 한 번만 사용)
    const ageGroupLabels = [
        "10대",
        "10살 미만",
        "20~30대",
        "40~50대",
        "60대 이상"
    ];

    // 연령대별 여러 개의 조언 문구 (나이 언급 없이 조언만 작성)
    // 인덱스 0~4는 Teachable Machine 모델의 클래스 순서와 맞추어야 함
    const adviceMessages = [
    [ // 10대
        "지금 느끼는 불안이나 혼란은 잘못된 게 아니라, 성장하고 있다는 신호예요.",
        "아직 방향이 안 잡힌 것 같아도 괜찮아요. 대부분은 이 시기에 헤매요.",
        "남들과 비교하면서 스스로를 깎아내리지 않아도 돼요. 각자 속도가 달라요.",
        "실패를 겁내지 말고 한 번쯤 부딪혀 보세요. 이 시기의 실패는 경험이 됩니다.",
        "잘하는 게 없어 보여도 걱정 마세요. 찾고 있는 중일 뿐이에요.",
        "어른들 말이 항상 정답은 아니에요. 듣되, 스스로 생각해 보세요.",
        "지금의 선택 하나가 인생 전부를 결정하지는 않아요.",
        "감정이 자주 흔들린다는 건, 그만큼 진지하게 살고 있다는 뜻이에요.",
        "공부 말고도 나를 설명해 줄 무언가 하나쯤은 꼭 가져보세요.",
        "지금의 나는 미완성이어도 괜찮아요. 아직 만들어지는 중이에요."
    ],
    [ // 10살 미만
        "궁금한 게 생기면 꼭 물어봐도 돼요. 질문하는 건 용기 있는 행동이에요.",
        "틀려도 괜찮아요. 실수하면서 배우는 거예요.",
        "처음부터 잘할 필요는 없어요. 천천히 해도 돼요.",
        "하고 싶은 말이 있으면 말해도 돼요. 네 생각은 중요해요.",
        "놀면서 배우는 것도 아주 중요한 공부예요.",
        "다른 친구보다 느려도 괜찮아요. 너만의 속도가 있어요.",
        "싫은 건 싫다고 말해도 돼요. 그건 나쁜 게 아니에요.",
        "혼자 해냈을 때의 기분을 기억해 보세요. 그게 자신감이에요.",
        "넘어져도 다시 일어나면 돼요. 그게 제일 멋진 거예요.",
        "지금의 너도 충분히 잘하고 있어요."
    ],
    [ // 20~30대
        "지금의 불안은 실패가 아니라, 선택 앞에 서 있다는 증거예요.",
        "남들보다 늦은 것 같아도 사실 대부분 비슷하게 고민하고 있어요.",
        "완벽한 타이밍은 잘 오지 않아요. 괜찮을 때 시작해도 됩니다.",
        "하고 있는 선택이 맞는지 고민하는 건 책임감이 있다는 뜻이에요.",
        "방향이 바뀌어도 괜찮아요. 돌아가는 길도 결국 경험이 됩니다.",
        "조급해질수록 잠깐 멈춰 숨을 고르는 게 필요해요.",
        "작은 성취라도 스스로 인정해 주세요. 생각보다 많이 해내고 있어요.",
        "일과 삶 사이에서 균형을 찾으려는 노력도 중요한 성장입니다.",
        "남의 인생 계획보다, 나에게 맞는 리듬을 더 믿어보세요.",
        "지금의 선택들이 모여 결국 당신만의 길이 만들어질 거예요."
    ],
    [ // 40~50대
        "앞만 보고 달려오느라 놓친 감정이 있다면, 이제는 돌아봐도 괜찮은 때예요.",
        "지금까지 쌓아온 경험은 생각보다 훨씬 큰 자산이에요.",
        "모든 걸 혼자 책임지려 하지 않아도 됩니다.",
        "잠시 쉬어간다고 해서 뒤처지는 건 아니에요.",
        "지금의 고민은 그만큼 성실히 살아왔다는 증거예요.",
        "예전보다 달라진 자신을 부정하지 말고 인정해 주세요.",
        "누군가를 위해 살아온 만큼, 이제는 나 자신도 챙겨도 괜찮아요.",
        "완벽하지 않아도 충분히 잘해왔어요.",
        "지금의 선택도 여전히 삶을 바꿀 힘이 있어요.",
        "당신의 시간은 아직 끝나지 않았습니다."
    ],
    [ // 60대 이상
        "지나온 시간을 돌아보면, 의미 없던 순간은 거의 없었을 거예요.",
        "새로운 걸 시작하기엔 절대 늦지 않았습니다.",
        "지금까지 살아온 경험은 그 자체로 큰 지혜입니다.",
        "예전보다 느려져도 괜찮아요. 속도보다 방향이 중요해요.",
        "몸과 마음의 신호를 예전보다 더 잘 들어주세요.",
        "작은 일상 속에서도 충분히 기쁨을 찾을 수 있어요.",
        "누군가에게 조언이 되어줄 만큼의 삶을 이미 살아오셨어요.",
        "지금의 여유는 노력 없이 얻어진 게 아닙니다.",
        "새로운 하루를 맞이할 수 있다는 것만으로도 충분한 가치가 있어요.",
        "지금의 당신도 여전히 성장하고 있습니다."
    ]
];

    // Load the image model and setup the webcam (페이지 로드시 한 번 실행)
    async function init() {
        const measureButton = document.getElementById("measure-button");
        
        try {
            // 측정 버튼 비활성화 및 로딩 상태 표시
            if (measureButton) {
                measureButton.disabled = true;
                measureButton.textContent = "웹캠 준비 중...";
            }

            // 라이브러리 로드 확인
            const tmImageLib = window.tmImage;
            if (!tmImageLib) {
                throw new Error("tmImage 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.");
            }

            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";

            console.log("모델 로딩 및 웹캠 준비 시작");

            // 모델 로드와 웹캠 준비를 병렬로 진행해서 체감 속도 향상
            const tmLoadPromise = tmImageLib.load(modelURL, metadataURL);

            const flip = true; // whether to flip the webcam
            webcam = new tmImageLib.Webcam(200, 200, flip); // width, height, flip
            console.log("웹캠 설정 중...");
            const webcamSetupPromise = (async () => {
                await webcam.setup({ facingMode: "user" }); // request access to the webcam
                await webcam.play();
                document.getElementById("webcam-container").appendChild(webcam.canvas);
            })();

            // 둘 다 끝날 때까지 기다림
            const [loadedModel] = await Promise.all([tmLoadPromise, webcamSetupPromise]);
            model = loadedModel;
            maxPredictions = model.getTotalClasses();

            console.log("모델 로드 및 웹캠 시작 완료. 클래스 수:", maxPredictions);

            // 첫 추론 워밍업으로 초기 클릭 지연 최소화
            try {
                await model.predict(webcam.canvas);
                if (window.tf && typeof window.tf.nextFrame === "function") {
                    await window.tf.nextFrame();
                }
                console.log("워밍업 완료");
            } catch (warmErr) {
                console.warn("워밍업 중 경고:", warmErr);
            }

            window.requestAnimationFrame(loop);

            // 라벨 영역 준비
            labelContainer = document.getElementById("label-container");
            resultTitleEl = document.getElementById("result-title");
            resultAgeEl = document.getElementById("result-age");
            resultAdviceEl = document.getElementById("result-advice");
            resultExpireEl = document.getElementById("result-expire");
            
            // 측정 버튼을 다시 활성화
            if (measureButton) {
                measureButton.disabled = false;
                measureButton.textContent = "조언 받기";
            }
        } catch (err) {
            console.error("초기화 오류:", err);
            alert("초기화 오류: " + (err && err.message ? err.message : err));
            
            // 버튼 복구
            if (measureButton) {
                measureButton.disabled = false;
                measureButton.textContent = "조언 받기";
            }
        }
    }

    // "조언 받기" / "다시 조언 받기" 버튼 클릭 핸들러
    function onMeasureButtonClick() {
        // 이미 측정 중이면 무시
        if (isMeasuring) return;

        // 모델/웹캠이 아직 준비되지 않은 경우 방어
        if (!(model && webcam && labelContainer)) {
            alert("아직 준비 중입니다. 잠시 후 다시 시도해주세요.");
            return;
        }

        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            playButtonBurst(measureButton);
        }

        startMeasure();
    }

    async function loop() {
        if (webcam) {
            webcam.update(); // update the webcam frame
            await predict();
            window.requestAnimationFrame(loop);
        }
    }

    // run the webcam image through the image model
    async function predict() {
        // predict can take in an image, video or canvas html element
        if (!(model && webcam && labelContainer)) return;

        const now = Date.now();
        const elapsed = now - measureStartTime;

        // 측정 중이 아닐 때도 프로그래스 바는 100%로 고정
        updateProgressUI(elapsed);

        // 이미 한 번 최종 결과가 나온 뒤라면 더 이상 누적하지 않음
        if (measurementDone || !isMeasuring) return;

        // 설정한 측정 시간 동안만 값을 누적
        if (elapsed <= MEASURE_DURATION_MS) {
            const prediction = await model.predict(webcam.canvas);

            // 각 나이대의 확률을 누적해서 "평균"을 구할 수 있도록 함
            for (let i = 0; i < prediction.length; i++) {
                classScoreSums[i] += prediction[i].probability;
            }
        } else {
            // 설정한 시간이 지나면 가장 많이 나온(누적 점수가 높은) 나이대를 최종 결과로 선택
            measurementDone = true;
            isMeasuring = false;

            let bestIndex = 0;
            for (let i = 1; i < classScoreSums.length; i++) {
                if (classScoreSums[i] > classScoreSums[bestIndex]) {
                    bestIndex = i;
                }
            }

            // 최종 나이대에 따라 조언 문구를 랜덤으로 선택
            let ageLabel = "";
            let adviceText = "알 수 없음";

            const ageAdvices = adviceMessages[bestIndex];
            if (ageAdvices && ageAdvices.length > 0) {
                const randomIdx = Math.floor(Math.random() * ageAdvices.length);
                adviceText = ageAdvices[randomIdx];
            }
            if (ageGroupLabels[bestIndex]) {
                ageLabel = "예상 연령대: " + ageGroupLabels[bestIndex];
            }

            if (resultTitleEl) {
                resultTitleEl.style.display = "block";
                resultTitleEl.textContent = "최종 판단 결과";
            }
            if (resultAgeEl) {
                resultAgeEl.style.display = ageLabel ? "inline-block" : "none";
                resultAgeEl.textContent = ageLabel;
            }
            if (resultAdviceEl) {
                resultAdviceEl.style.display = "block";
                resultAdviceEl.textContent = adviceText;
            }

            // 측정 종료 UI 및 다시 하기 버튼 보이기
            finishMeasureUI();
        }
    }

    // 측정 초기화 및 시작 공통 로직
    function startMeasure() {
        clearAutoResetTimer();
        classScoreSums = new Array(maxPredictions).fill(0);
        isMeasuring = true;
        measurementDone = false;
        measureStartTime = Date.now();

        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (progressWrapper && progressText && progressBar) {
            progressWrapper.style.display = "block";
            progressText.style.display = "block";
            progressBar.style.width = "0%";
            const totalSeconds = MEASURE_DURATION_MS / 1000;
            progressText.textContent = totalSeconds + "초 동안 화면을 바라봐 주세요. 평균 나이대를 계산 중입니다...";
        }

        // 결과 박스 초기화 및 숨김
        if (resultTitleEl) {
            resultTitleEl.style.display = "none";
            resultTitleEl.textContent = "";
        }
        if (resultAgeEl) {
            resultAgeEl.style.display = "none";
            resultAgeEl.textContent = "";
        }
        if (resultAdviceEl) {
            resultAdviceEl.style.display = "none";
            resultAdviceEl.textContent = "";
        }
        if (resultExpireEl) {
            resultExpireEl.style.display = "none";
            resultExpireEl.textContent = "";
        }

        // 측정 버튼 비활성화 및 상태 표시
        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            measureButton.disabled = true;
            measureButton.textContent = "측정 중...";
        }
    }

    // 측정 종료 시 UI 업데이트
    function finishMeasureUI() {
        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (progressWrapper && progressText && progressBar) {
            progressBar.style.width = "100%";
            progressText.textContent = "측정이 완료되었습니다.";
        }

        // 측정 버튼을 다시 활성화하고 "다시 조언 받기"으로 변경
        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            measureButton.disabled = false;
            measureButton.textContent = "다시 조언 받기";
        }

        // 결과 자동 초기화 안내 및 타이머 설정
        if (resultExpireEl) {
            resultExpireEl.style.display = "block";
            resultExpireEl.textContent = "15초 뒤 결과가 자동으로 초기화됩니다.";
        }
        scheduleAutoReset();
    }

    // 경과 시간에 따라 프로그래스 바/텍스트 업데이트
    function updateProgressUI(elapsedMs) {
        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (!(progressWrapper && progressText && progressBar)) return;

        // 아직 측정 시작 전이면 숨김
        if (!isMeasuring && !measurementDone) {
            progressWrapper.style.display = "none";
            progressText.style.display = "none";
            return;
        }

        const ratio = Math.min(elapsedMs / MEASURE_DURATION_MS, 1);
        const percent = Math.round(ratio * 100);
        progressBar.style.width = percent + "%";

        const totalSeconds = MEASURE_DURATION_MS / 1000;
        const remainingSeconds = Math.max(totalSeconds - Math.floor(elapsedMs / 1000), 0);

        if (!measurementDone) {
            progressText.textContent = "남은 시간: " + remainingSeconds + "초";
        }
    }

    // 버튼 주변에서만 보이는 "팡" 이펙트 (작은 링이 번지는 효과)
    function playButtonBurst(buttonEl) {
        if (!buttonEl) return;
        buttonEl.classList.remove("burst-active");
        // reflow를 강제로 발생시켜 애니메이션을 다시 트리거
        void buttonEl.offsetWidth;
        buttonEl.classList.add("burst-active");
    }

    // 결과를 15초 뒤 자동으로 초기화
    function scheduleAutoReset() {
        clearAutoResetTimer();
        autoResetTimerId = setTimeout(() => {
            resetResultsToInitial();
        }, RESULT_AUTO_RESET_MS);
    }

    function clearAutoResetTimer() {
        if (autoResetTimerId) {
            clearTimeout(autoResetTimerId);
            autoResetTimerId = null;
        }
    }

    function resetResultsToInitial() {
        measurementDone = false;
        isMeasuring = false;
        measureStartTime = 0;
        classScoreSums = new Array(maxPredictions || 0).fill(0);

        // 결과 박스 숨김
        if (resultTitleEl) {
            resultTitleEl.style.display = "none";
            resultTitleEl.textContent = "";
        }
        if (resultAgeEl) {
            resultAgeEl.style.display = "none";
            resultAgeEl.textContent = "";
        }
        if (resultAdviceEl) {
            resultAdviceEl.style.display = "none";
            resultAdviceEl.textContent = "";
        }
        if (resultExpireEl) {
            resultExpireEl.style.display = "none";
            resultExpireEl.textContent = "";
        }

        // 프로그래스 영역 초기화
        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (progressWrapper && progressText && progressBar) {
            progressWrapper.style.display = "none";
            progressText.style.display = "none";
            progressText.textContent = "";
            progressBar.style.width = "0%";
        }

        // 버튼 텍스트 초기화
        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            measureButton.disabled = false;
            measureButton.textContent = "조언 받기";
        }
    }
    </script>

</body>
</html>
