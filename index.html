<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H R & Y C 's Project</title>
    <link rel="icon" href="icon1.jpg"/> 
    <link rel="apple-touch-icon" href="icon1.jpg"/> 
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app">
        <div class="card">
            <div class="card-title">얼굴 나이에 맞는 조언 프로그램</div>

            <div class="content-row">
                <div class="cam-panel">
                    <div id="webcam-container"></div>
                </div>

                <div class="info-panel">
                    <div id="label-container">
                        <div id="result-title"></div>
                        <div id="result-age"></div>
                        <div id="result-advice"></div>
                    </div>
                </div>
            </div>

            <!-- 아래쪽 중앙: 프로그래스 바 + 버튼 -->
            <div class="bottom-panel">
                <div id="progress-wrapper">
                    <div id="progress-bar"></div>
                </div>
                <div id="progress-text"></div>

                <div class="button-row">
                    <button type="button" id="measure-button" onclick="onMeasureButtonClick()">나이 추정 시작</button>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <script type="text/javascript">
    // More API functions here:
    // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/image

    // the link to your model provided by Teachable Machine export panel
    const URL = "./";

    // 사용할 기본 테마 선택: "theme-light" | "theme-dark" | "theme-pastel" 중 하나
    const DEFAULT_THEME = "theme-light";

    // 페이지 로드가 완료되면 기본 테마 적용 + 웹캠/모델 초기화
    document.addEventListener("DOMContentLoaded", () => {
        document.body.classList.add(DEFAULT_THEME);
        init(); // 페이지에 들어오자마자 웹캠을 켜고 모델을 준비
    });

    let model, webcam, labelContainer, maxPredictions;
    let resultTitleEl, resultAgeEl, resultAdviceEl;

    // 측정 시간(밀리초) - 필요하면 이 값만 바꾸면 됨
    const MEASURE_DURATION_MS = 5000;  // 5초

    // 평균을 내기 위한 상태 변수
    let isMeasuring = false;          // 지금 측정 중인지 여부
    let measurementDone = false;      // 최종 결과가 이미 나온 상태인지 여부
    let measureStartTime = 0;         // 측정 시작 시각
    let classScoreSums = [];          // 각 나이대에 대한 누적 점수

    // 연령대 이름을 따로 관리 (접두사 "예상 연령대:"는 코드에서 한 번만 사용)
    const ageGroupLabels = [
        "10대",
        "10살 미만",
        "20~30대",
        "40~50대",
        "60대 이상"
    ];

    // 연령대별 여러 개의 조언 문구 (나이 언급 없이 조언만 작성)
    // 인덱스 0~4는 Teachable Machine 모델의 클래스 순서와 맞추어야 함
    const adviceMessages = [
    [
        "지금의 불안함이나 흔들림도 성장 과정의 일부니까 너무 조급해하지 마세요. 천천히 자기 속도를 찾아가면 돼요.",
        "하고 싶은 일이 마음에 떠오르면 이유를 따지기보다 먼저 한 걸음만 내딛어 보세요. 그 한 걸음이 인생의 방향을 바꿀 수 있어요.",
        "완벽해야 한다는 부담은 내려놓고, 오늘의 작은 실천 하나에 집중해 보세요. 작은 변화들이 모여 나중에 큰 힘이 됩니다."
    ],
    [
        "새로운 것을 보면 먼저 만져보고, 해보고, 느껴보세요. 세상을 배워가는 가장 좋은 방법이에요.",
        "틀려도 괜찮고, 천천히 해도 괜찮아요. 중요한 건 즐겁게 해보려는 마음이에요.",
        "하고 싶은 게 생기면 말로 표현해 보세요. 그 한마디가 더 많은 재미를 불러올 수 있어요."
    ],
    [
        "지금 겪는 고민이나 선택의 압박은 자연스러운 과정이에요. 너무 잘하려고 하기보다, 지금의 나에게 솔직해지는 게 더 중요합니다.",
        "다른 사람의 속도가 부러울 수 있지만, 결국 오래 가는 건 자신만의 페이스를 지키는 사람입니다.",
        "작은 목표라도 꾸준히 쌓아가면 어느 순간 자신이 생각보다 멀리 와 있는 걸 깨닫게 될 거예요."
    ],
    [
        "앞만 보고 달려오느라 놓쳤던 감정이나 생각이 있다면, 지금은 그것을 차분히 돌아볼 좋은 때입니다.",
        "지금까지 쌓아온 경험은 누구도 흉내낼 수 없는 큰 자산이에요. 그 가치를 스스로 믿어주세요.",
        "누군가를 위해 살아온 시간만큼, 이제는 나 자신을 돌보는 시간을 조금 더 챙겨도 충분히 괜찮습니다."
    ],
    [
        "지나온 길을 천천히 떠올려 보면, 삶의 의미 있는 순간들이 더 선명하게 다가올 거예요.",
        "새로운 것을 배우기엔 늦은 때는 없습니다. 작은 변화도 하루를 특별하게 만들어줍니다.",
        "몸과 마음을 편안하게 돌보면서, 지금의 여유가 주는 소소한 행복을 더 자주 느껴보세요."
    ]
];

    // Load the image model and setup the webcam (페이지 로드시 한 번 실행)
    async function init() {
        const measureButton = document.getElementById("measure-button");
        
        try {
            // 측정 버튼 비활성화 및 로딩 상태 표시
            if (measureButton) {
                measureButton.disabled = true;
                measureButton.textContent = "웹캠 준비 중...";
            }

            // 라이브러리 로드 확인
            const tmImageLib = window.tmImage;
            if (!tmImageLib) {
                throw new Error("tmImage 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.");
            }

            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";

            console.log("모델 로딩 및 웹캠 준비 시작");

            // 모델 로드와 웹캠 준비를 병렬로 진행해서 체감 속도 향상
            const tmLoadPromise = tmImageLib.load(modelURL, metadataURL);

            const flip = true; // whether to flip the webcam
            webcam = new tmImageLib.Webcam(200, 200, flip); // width, height, flip
            console.log("웹캠 설정 중...");
            const webcamSetupPromise = (async () => {
                await webcam.setup({ facingMode: "user" }); // request access to the webcam
                await webcam.play();
                document.getElementById("webcam-container").appendChild(webcam.canvas);
            })();

            // 둘 다 끝날 때까지 기다림
            const [loadedModel] = await Promise.all([tmLoadPromise, webcamSetupPromise]);
            model = loadedModel;
            maxPredictions = model.getTotalClasses();

            console.log("모델 로드 및 웹캠 시작 완료. 클래스 수:", maxPredictions);

            window.requestAnimationFrame(loop);

            // 라벨 영역 준비
            labelContainer = document.getElementById("label-container");
            resultTitleEl = document.getElementById("result-title");
            resultAgeEl = document.getElementById("result-age");
            resultAdviceEl = document.getElementById("result-advice");
            
            // 측정 버튼을 다시 활성화
            if (measureButton) {
                measureButton.disabled = false;
                measureButton.textContent = "나이 추정 시작";
            }
        } catch (err) {
            console.error("초기화 오류:", err);
            alert("초기화 오류: " + (err && err.message ? err.message : err));
            
            // 버튼 복구
            if (measureButton) {
                measureButton.disabled = false;
                measureButton.textContent = "나이 추정 시작";
            }
        }
    }

    // "나이 추정 시작" / "다시 추정" 버튼 클릭 핸들러
    function onMeasureButtonClick() {
        // 이미 측정 중이면 무시
        if (isMeasuring) return;

        // 모델/웹캠이 아직 준비되지 않은 경우 방어
        if (!(model && webcam && labelContainer)) {
            alert("아직 준비 중입니다. 잠시 후 다시 시도해주세요.");
            return;
        }

        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            playButtonBurst(measureButton);
        }

        startMeasure();
    }

    async function loop() {
        if (webcam) {
            webcam.update(); // update the webcam frame
            await predict();
            window.requestAnimationFrame(loop);
        }
    }

    // run the webcam image through the image model
    async function predict() {
        // predict can take in an image, video or canvas html element
        if (!(model && webcam && labelContainer)) return;

        const now = Date.now();
        const elapsed = now - measureStartTime;

        // 측정 중이 아닐 때도 프로그래스 바는 100%로 고정
        updateProgressUI(elapsed);

        // 이미 한 번 최종 결과가 나온 뒤라면 더 이상 누적하지 않음
        if (measurementDone || !isMeasuring) return;

        // 설정한 측정 시간 동안만 값을 누적
        if (elapsed <= MEASURE_DURATION_MS) {
            const prediction = await model.predict(webcam.canvas);

            // 각 나이대의 확률을 누적해서 "평균"을 구할 수 있도록 함
            for (let i = 0; i < prediction.length; i++) {
                classScoreSums[i] += prediction[i].probability;
            }
        } else {
            // 설정한 시간이 지나면 가장 많이 나온(누적 점수가 높은) 나이대를 최종 결과로 선택
            measurementDone = true;
            isMeasuring = false;

            let bestIndex = 0;
            for (let i = 1; i < classScoreSums.length; i++) {
                if (classScoreSums[i] > classScoreSums[bestIndex]) {
                    bestIndex = i;
                }
            }

            // 최종 나이대에 따라 조언 문구를 랜덤으로 선택
            let ageLabel = "";
            let adviceText = "알 수 없음";

            const ageAdvices = adviceMessages[bestIndex];
            if (ageAdvices && ageAdvices.length > 0) {
                const randomIdx = Math.floor(Math.random() * ageAdvices.length);
                adviceText = ageAdvices[randomIdx];
            }
            if (ageGroupLabels[bestIndex]) {
                ageLabel = "예상 연령대: " + ageGroupLabels[bestIndex];
            }

            if (resultTitleEl) {
                resultTitleEl.style.display = "block";
                resultTitleEl.textContent = "최종 판단 결과";
            }
            if (resultAgeEl) {
                resultAgeEl.style.display = ageLabel ? "inline-block" : "none";
                resultAgeEl.textContent = ageLabel;
            }
            if (resultAdviceEl) {
                resultAdviceEl.style.display = "block";
                resultAdviceEl.textContent = adviceText;
            }

            // 측정 종료 UI 및 다시 하기 버튼 보이기
            finishMeasureUI();
        }
    }

    // 측정 초기화 및 시작 공통 로직
    function startMeasure() {
        classScoreSums = new Array(maxPredictions).fill(0);
        isMeasuring = true;
        measurementDone = false;
        measureStartTime = Date.now();

        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (progressWrapper && progressText && progressBar) {
            progressWrapper.style.display = "block";
            progressText.style.display = "block";
            progressBar.style.width = "0%";
            const totalSeconds = MEASURE_DURATION_MS / 1000;
            progressText.textContent = totalSeconds + "초 동안 화면을 바라봐 주세요. 평균 나이대를 계산 중입니다...";
        }

        // 결과 박스 초기화 및 숨김
        if (resultTitleEl) {
            resultTitleEl.style.display = "none";
            resultTitleEl.textContent = "";
        }
        if (resultAgeEl) {
            resultAgeEl.style.display = "none";
            resultAgeEl.textContent = "";
        }
        if (resultAdviceEl) {
            resultAdviceEl.style.display = "none";
            resultAdviceEl.textContent = "";
        }

        // 측정 버튼 비활성화 및 상태 표시
        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            measureButton.disabled = true;
            measureButton.textContent = "측정 중...";
        }
    }

    // 측정 종료 시 UI 업데이트
    function finishMeasureUI() {
        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (progressWrapper && progressText && progressBar) {
            progressBar.style.width = "100%";
            progressText.textContent = "측정이 완료되었습니다.";
        }

        // 측정 버튼을 다시 활성화하고 "다시 추정"으로 변경
        const measureButton = document.getElementById("measure-button");
        if (measureButton) {
            measureButton.disabled = false;
            measureButton.textContent = "다시 추정";
        }
    }

    // 경과 시간에 따라 프로그래스 바/텍스트 업데이트
    function updateProgressUI(elapsedMs) {
        const progressWrapper = document.getElementById("progress-wrapper");
        const progressText = document.getElementById("progress-text");
        const progressBar = document.getElementById("progress-bar");
        if (!(progressWrapper && progressText && progressBar)) return;

        // 아직 측정 시작 전이면 숨김
        if (!isMeasuring && !measurementDone) {
            progressWrapper.style.display = "none";
            progressText.style.display = "none";
            return;
        }

        const ratio = Math.min(elapsedMs / MEASURE_DURATION_MS, 1);
        const percent = Math.round(ratio * 100);
        progressBar.style.width = percent + "%";

        const totalSeconds = MEASURE_DURATION_MS / 1000;
        const remainingSeconds = Math.max(totalSeconds - Math.floor(elapsedMs / 1000), 0);

        if (!measurementDone) {
            progressText.textContent = "남은 시간: " + remainingSeconds + "초";
        }
    }

    // 버튼 주변에서만 보이는 "팡" 이펙트 (작은 링이 번지는 효과)
    function playButtonBurst(buttonEl) {
        if (!buttonEl) return;
        buttonEl.classList.remove("burst-active");
        // reflow를 강제로 발생시켜 애니메이션을 다시 트리거
        void buttonEl.offsetWidth;
        buttonEl.classList.add("burst-active");
    }
    </script>

</body>
</html>
